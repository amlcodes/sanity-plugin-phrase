import { SanityClient } from 'sanity'
import { SanityTMD, TMDStatus } from '../types'
import { TMD_TYPE, comesFromSanity } from '../utils'
import {
  ProjectDeletedWebhook,
  ProjectDueDateChangedWebhook,
  ProjectMetadataUpdatedWebhook,
  ProjectStatusChangedWebhook,
} from './handlePhraseWebhook'

export default async function updateTMDFromProjectWebhook({
  sanityClient,
  payload,
}: {
  sanityClient: SanityClient
  payload:
    | ProjectDeletedWebhook
    | ProjectStatusChangedWebhook
    | ProjectDueDateChangedWebhook
    | ProjectMetadataUpdatedWebhook
}) {
  const { project } = payload
  if (!comesFromSanity(project)) {
    return {
      status: 200,
      body: { message: "Project isn't generated by Sanity" },
    } as const
  }

  const TMD = await sanityClient.fetch<SanityTMD | null>(
    `*[_type == "${TMD_TYPE}" && phraseProjectUid == $phraseProjectUid][0]`,
    {
      phraseProjectUid: project.uid,
    },
  )

  if (!TMD) {
    return {
      status: 404,
      body: { error: "Couldn't find matching translation for project" },
    } as const
  }

  const newStatus: TMDStatus =
    payload.event === 'PROJECT_DELETED' ? 'DELETED' : payload.project.status

  const tx = sanityClient.transaction()
  tx.patch(TMD._id, (patch) => {
    patch.set({
      status: newStatus,
    } as Pick<SanityTMD, 'status'>)

    if (
      payload.project?.dateDue &&
      payload.project.dateDue !== TMD.projectDueDate
    ) {
      patch.set({
        projectDueDate: payload.project.dateDue,
      } as Pick<SanityTMD, 'projectDueDate'>)
    }

    return patch
  })

  try {
    await tx.commit({ returnDocuments: false })
    return {
      status: 200,
      body: {
        message: `Updated TMD with status ${newStatus}`,
      },
    }
  } catch (error) {
    return {
      status: 500,
      body: { error: "Couldn't update statuses", attemptedTx: tx.toJSON() },
    } as const
  }
}
